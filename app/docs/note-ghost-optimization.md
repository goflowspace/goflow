# Оптимизация отображения призрака заметок (Note Ghost)

## Проблема

В ходе реализации функциональности заметок (Notes) в редакторе была обнаружена проблема с производительностью. 
Призрак заметки (NoteNodeGhost), который отображается при выборе инструмента "Заметка", 
двигался с существенной задержкой относительно курсора (примерно 1-3 секунды). 
Другие типы призраков (Narrative, Stack, Layer) двигались плавно, без заметной задержки.

## Анализ и причины проблемы

После тщательного анализа были выявлены следующие факторы, влияющие на производительность:

1. **CSS-переходы и трансформации**: 
   - В `NoteNode.module.scss` для класса `.note_wrapper` был определен `transition: all 0.2s ease;`
   - Стиль также включал `transform: rotate(-1deg);` для эффекта наклоненной заметки
   - Эти свойства наследовались призраком, что вызывало задержку из-за постоянных пересчетов CSS-трансформаций

2. **Отсутствие мемоизации**: 
   - Компонент `NoteNodeGhost` не использовал `React.memo()`, в отличие от других призраков (StackNodeGhost, LayerNodeGhost)
   - Это приводило к лишним ререндерам при каждом изменении позиции курсора

3. **Сложная DOM-структура**: 
   - Призрак содержал вложенные div-элементы с дополнительными классами
   - Это увеличивало время рендеринга и применения стилей

4. **Неэффективная обработка движения мыши**:
   - Использовался простой обработчик без оптимизации
   - Отсутствовал механизм синхронизации с частотой обновления экрана

5. **Использование нестандартного шрифта**:
   - Изначально использовался шрифт 'Courier New', который отличался от основного шрифта интерфейса
   - Это вызывало дополнительную нагрузку на рендеринг и создавало визуальный диссонанс

## Внесенные изменения

### 1. Оптимизация CSS стилей

В `src/components/nodes/NoteNode/NoteNode.module.scss` были внесены следующие изменения:

```scss
.ghost {
  position: absolute;
  width: 180px;
  min-height: 120px;
  pointer-events: none;
  opacity: 0.7;
  z-index: 10;
  background-color: #fffad1;
  border-radius: 5px;
  border: 1px solid #e6e0a5;
  padding: 10px;
  font-family: 'Inter', sans-serif;
  transform: none !important;  // Отключаем наклон для призрака
  transition: none !important;  // Отключаем переходы полностью
  box-shadow: none !important;  // Отключаем тени
}
```

Теперь классу `.ghost` явно заданы все необходимые стили, переопределены тяжелые эффекты 
(трансформации, переходы и тени) с использованием `!important` и задан шрифт Inter, соответствующий 
основному шрифту интерфейса.

### 2. Оптимизация компонента `NoteNodeGhost`

Компонент был полностью переработан для повышения производительности:

```jsx
'use client';

import {CSSProperties, memo} from 'react';
import {useViewport} from '@xyflow/react';
import cls from 'classnames';
import s from './NoteNode.module.scss';

// Используем memo для предотвращения лишних ререндеров
const NoteNodeGhost = memo(({position}: NoteNodeGhostProps) => {
  const {zoom} = useViewport();

  const style: CSSProperties = {
    position: 'absolute',
    left: position.x,
    top: position.y,
    pointerEvents: 'none',
    zIndex: 9999,
    transform: `scale(${zoom})`,
    transformOrigin: 'top left'
  };

  // Упрощенная DOM-структура для лучшей производительности
  return (
    <div className={s.ghost} style={style}>
      <span style={{fontFamily: 'Inter, sans-serif'}}>Add note here...</span>
    </div>
  );
});

NoteNodeGhost.displayName = 'NoteNodeGhost';

export default NoteNodeGhost;
```

Основные улучшения:
- Добавлена мемоизация компонента с помощью `memo`
- Упрощена DOM-структура (один div вместо вложенных элементов)
- Добавлено `displayName` для лучшей отладки в React DevTools
- Использование шрифта Inter для единообразия с остальным интерфейсом

### 3. Улучшение обработки движения мыши в Canvas

В компоненте `Canvas.tsx` был реализован более эффективный обработчик движения мыши:

```jsx
// Обновляем глобальный обработчик движения мыши для отслеживания позиции курсора для призрака
useEffect(() => {
  if (activeTool !== 'cursor') {
    const handleGlobalMouseMoveForGhost = (e: globalThis.MouseEvent) => {
      if (wrapperRef.current) {
        const bounds = wrapperRef.current.getBoundingClientRect();
        // Использование requestAnimationFrame для синхронизации с частотой кадров
        requestAnimationFrame(() => {
          setCursorPos({
            x: e.clientX - bounds.left,
            y: e.clientY - bounds.top
          });
        });
      }
    };

    // Добавляем обработчик для всех инструментов кроме курсора
    window.addEventListener('mousemove', handleGlobalMouseMoveForGhost);

    return () => {
      window.removeEventListener('mousemove', handleGlobalMouseMoveForGhost);
    };
  } else {
    // Для cursor сбрасываем отображение призрака
    setCursorPos(null);
  }
}, [activeTool, wrapperRef]);

// Пустой обработчик для onMouseMove, все обрабатывается через глобальный обработчик
const handleMouseMove = useCallback((e: React.MouseEvent) => {
  // Пустая функция, реальная обработка происходит в глобальном обработчике
}, []);
```

Ключевые улучшения:
- Использование глобального обработчика движения мыши для непрерывного отслеживания
- Применение `requestAnimationFrame` для синхронизации обновлений с частотой кадров
- Оптимизация логики обновления позиции курсора

## Результаты

После внесенных изменений:
- Призрак заметки движется плавно и синхронно с курсором
- Устранена задержка в 1-3 секунды
- Поведение призрака аналогично другим типам призраков (Narrative, Stack, Layer)
- Улучшена общая производительность интерфейса при работе с инструментом заметок

## Выводы и рекомендации

1. **Избегать тяжелых CSS-эффектов** для элементов, требующих частого обновления позиции
2. **Использовать `memo` для компонентов**, положение которых часто обновляется
3. **Применять `requestAnimationFrame`** для синхронизации визуальных обновлений
4. **Упрощать DOM-структуру** для элементов, критичных к производительности
5. **Явно переопределять стили** в дочерних классах, если родительские стили содержат тяжелые эффекты

Эти принципы рекомендуется применять при реализации любых элементов интерфейса, 
которые должны плавно реагировать на движение курсора или другие частые изменения. 