# Реализация масштабирования в Go Flow

## Описание проблемы

Изначально в приложении были следующие проблемы с масштабированием:

1. **Несогласованное поведение для разных устройств ввода**:
   - На тачпаде жест двумя пальцами масштабировал вместо прокрутки, что не соответствует ожидаемому UX
   - На мыши колесо иногда не выполняло масштабирование
   
2. **Неточное определение типа устройства ввода**:
   - Трудно надежно различить тачпад и мышь на основе событий колеса
   - Разные браузеры и ОС могут генерировать разные события
   
3. **Неотзывчивый зум**:
   - Анимация масштабирования создавала ощущение задержки
   - Зум происходил относительно центра экрана, а не позиции курсора
   
4. **Ошибки в логике обработки событий**:
   - Возникали ошибки `Cannot read properties of null (reading 'getBoundingClientRect')`
   - Не всегда правильно обрабатывались события колеса при разных комбинациях клавиш

## Внесенные изменения

### 1. Разделение логики для разных устройств ввода

```javascript
// Определение типа устройства ввода
const isMouse = e.deltaMode !== 0 || Math.abs(e.deltaY) > 100;

// Для мыши
if (isMouse) {
  // Всегда масштабируем при скролле, без необходимости Ctrl/Cmd
  zoomToPointer(e, e.deltaY < 0 ? 1 : -1);
}
// Для тачпада
else {
  // Масштабируем только с Ctrl/Cmd
  if (e.ctrlKey || e.metaKey) {
    zoomToPointer(e, e.deltaY < 0 ? 1 : -1);
  }
  // Иначе разрешаем обычную прокрутку
}
```

### 2. Реализация масштабирования относительно курсора

```javascript
const zoomToPointer = (event, zoomStep) => {
  // Получаем текущий viewport и координаты курсора
  const viewport = getViewport();
  const reactFlowBounds = event.currentTarget.getBoundingClientRect();
  
  // Позиция курсора на холсте
  const pointerX = event.clientX - reactFlowBounds.left;
  const pointerY = event.clientY - reactFlowBounds.top;
  
  // Позиция курсора в "мировых" координатах
  const worldX = (pointerX - viewport.x) / viewport.zoom;
  const worldY = (pointerY - viewport.y) / viewport.zoom;
  
  // Вычисляем новый масштаб
  const scaleFactor = zoomStep > 0 ? 1 + amount : 1 - amount;
  const newZoom = viewport.zoom * scaleFactor;
  
  // Пересчитываем позицию viewport так, чтобы курсор остался над той же точкой
  const newX = pointerX - worldX * newZoom;
  const newY = pointerY - worldY * newZoom;
  
  // Применяем новый viewport без анимации для максимальной отзывчивости
  setViewport({x: newX, y: newY, zoom: newZoom}, {duration: 0});
};
```

### 3. Оптимизация производительности

1. **Устранение задержек при масштабировании**:
   - Отключена анимация: `{duration: 0}`
   - Использование `requestAnimationFrame` для оптимизации:
   ```javascript
   requestAnimationFrame(() => {
     // логика масштабирования
   });
   ```

2. **Оптимизация коэффициента масштабирования**:
   - Адаптивный шаг в зависимости от deltaY:
   ```javascript
   const amount = Math.abs(event.deltaY) > 100 ? 0.2 : 0.05;
   ```

### 4. Обработка ошибок и повышение надежности

```javascript
try {
  // Проверка на наличие currentTarget
  let reactFlowBounds;
  if (event.currentTarget && event.currentTarget instanceof HTMLElement) {
    reactFlowBounds = event.currentTarget.getBoundingClientRect();
  } else {
    // Fallback стратегии
    if (wrapperRef.current) {
      reactFlowBounds = wrapperRef.current.getBoundingClientRect();
    } else {
      // ...другие способы получения bounds
    }
  }
  
  // Основная логика
} catch (error) {
  console.error('Error during zoom to pointer:', error);
  
  // Fallback на простое масштабирование без привязки к курсору
  const viewport = getViewport();
  const newZoom = viewport.zoom * (zoomStep > 0 ? 1.1 : 0.9);
  setViewport({...viewport, zoom: newZoom}, {duration: 0});
}
```

### 5. Конфигурация ReactFlow

```javascript
const config = {
  // Перемещение холста при зажатой ЛКМ
  panOnDrag: isTouch ? false : [1, 2, 32],
  
  // Панорамирование при скролле только для тачпада
  panOnScroll: isTouch, 
  
  // Режим панорамирования
  panOnScrollMode: PanOnScrollMode.Free,
  
  // Масштабирование через встроенную функцию отключено
  zoomOnScroll: false,
  
  // Активация зума отключена, т.к. используем кастомную логику
  zoomActivationKeyCode: undefined,
  
  // Масштабирование жестом щипка всегда включено
  zoomOnPinch: true
};
```

## Финальное поведение

1. **Тачпад (MacBook и т.п.)**:
   - Жест двумя пальцами вверх/вниз: панорамирование холста
   - Жест двумя пальцами + Ctrl/Cmd: масштабирование относительно курсора
   - Жест щипка/разведения пальцев: масштабирование

2. **Мышь**:
   - Колесо мыши вверх/вниз: масштабирование относительно курсора
   - Перетаскивание с зажатой ЛКМ: перемещение холста
   - Перетаскивание с зажатой ПКМ: выделение элементов

3. **Клавиатурные комбинации** (работают одинаково для всех устройств):
   - Ctrl/Cmd + "+": увеличение масштаба
   - Ctrl/Cmd + "-": уменьшение масштаба
   - Ctrl/Cmd + "0": вписать всё содержимое в экран

## Возможные проблемы и решения

1. **Сложность определения типа устройства ввода**:
   - Решение: эвристика на основе deltaMode и deltaY
   - Может не работать в некоторых случаях, дополнительная настройка может потребоваться

2. **Повышенное потребление ресурсов при частых событиях колеса**:
   - Решение: использование requestAnimationFrame для оптимизации
   - Можно добавить throttling/debouncing, если это станет проблемой

3. **Разное поведение в разных браузерах**:
   - Особенно проблематично для Safari и мобильных браузеров
   - Использованы события gesturestart/gesturechange для поддержки Safari

## Рекомендации по дальнейшему улучшению

1. **Добавить пользовательские настройки**:
   - Возможность инвертировать направление масштабирования
   - Настройка скорости/шага масштабирования

2. **Улучшить определение устройства ввода**:
   - Хранить информацию о последнем использованном устройстве
   - Использовать более сложные эвристики с machine learning

3. **Дополнительная оптимизация производительности**:
   - Deferring обновления до окончания скролла
   - Кеширование вычислений viewport

4. **Улучшить доступность**:
   - Добавить поддержку масштабирования через клавиатуру для людей с ограниченными возможностями
   - Добавить режим высокого контраста для слабовидящих

## Заключение

Реализованный механизм масштабирования значительно улучшает пользовательский опыт, делая его более интуитивным и соответствующим ожиданиям пользователей. Масштабирование происходит относительно положения курсора, что делает навигацию и работу с холстом более удобной и точной.

Ключевые преимущества:
- Дифференцированная обработка событий для разных устройств ввода
- Высокая отзывчивость и производительность
- Устойчивость к ошибкам
- Интуитивно понятное поведение, соответствующее стандартам UX 