# Обработка контекстного меню

## Проблема

Стандартное контекстное меню браузера (вызываемое правым кликом) могло мешать пользовательскому опыту в приложении. Потребовалось отключить стандартное меню для всех нередактируемых элементов, но сохранить его функциональность для текстовых полей и других редактируемых элементов.

## Решение

Решение разделено на две части из-за особенностей архитектуры Next.js App Router:

1. **Серверный компонент** (`src/app/layout.tsx`): содержит метаданные и структуру приложения
2. **Клиентский компонент** (`src/app/ClientLayout.tsx`): содержит логику обработки событий контекстного меню

### Почему потребовалось разделение?

В Next.js 13+ с App Router существуют особенности работы с серверными и клиентскими компонентами:

- Серверные компоненты не могут использовать клиентские хуки (например, `useEffect`)
- Компоненты с директивой `"use client"` (клиентские) не могут экспортировать метаданные (`metadata`)

### Как работает обработчик контекстного меню

В клиентском компоненте `ClientLayout.tsx` реализован обработчик события `contextmenu`, который:

1. Проверяет, является ли целевой элемент текстовым полем или редактируемым элементом:
   - `INPUT` элементы (текстовые поля, чекбоксы и т.д.)
   - `TEXTAREA` элементы (многострочные текстовые поля)
   - Элементы с атрибутом `contentEditable` (редактируемые блоки)

2. Если элемент **не является** редактируемым, обработчик отменяет стандартное поведение браузера с помощью `e.preventDefault()`.

3. Если элемент **является** редактируемым, стандартное контекстное меню браузера показывается (обработчик ничего не делает).

Обработчик добавляется при монтировании компонента и удаляется при его размонтировании через `useEffect`, чтобы избежать утечек памяти.

## Пример кода

Клиентский компонент (`src/app/ClientLayout.tsx`):

```tsx
"use client";

import React, { useEffect } from 'react';

const ClientLayout: React.FC<{children: React.ReactNode}> = ({children}) => {
  useEffect(() => {
    const handleContextMenu = (e: MouseEvent) => {
      // Проверяем, является ли целевой элемент текстовым полем или элементом с возможностью редактирования
      const target = e.target as HTMLElement;
      const isEditable = 
        target.tagName === 'INPUT' || 
        target.tagName === 'TEXTAREA' || 
        target.isContentEditable;
      
      // Если элемент не редактируемый - отменяем стандартное контекстное меню
      if (!isEditable) {
        e.preventDefault();
      }
    };

    // Добавляем обработчик события
    document.addEventListener('contextmenu', handleContextMenu);

    // Удаляем обработчик при размонтировании компонента
    return () => {
      document.removeEventListener('contextmenu', handleContextMenu);
    };
  }, []);

  return <>{children}</>;
};

export default ClientLayout;
```

## Возможные улучшения

- Добавить список определенных элементов или классов, для которых контекстное меню должно всегда отображаться
- Реализовать собственное контекстное меню для разных типов элементов
- Добавить настройку включения/отключения этой функциональности 