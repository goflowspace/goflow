# Исправление undo/redo для удаления стеков с узлами выбора

## Описание проблемы

В редакторе графов существовала проблема с функциональностью отмены (undo) и повтора (redo) при удалении стеков с узлами выбора. 

### Симптомы:
- Удаление отдельного узла выбора (не стека) корректно записывалось в историю, и функции undo/redo работали нормально.
- Однако при удалении стека с узлами выбора, в историю записывалось несколько отдельных команд:
  - Одна команда для удаления стека
  - Отдельные команды для каждого узла выбора внутри стека

Это приводило к неправильной работе функции undo/redo. При отмене (undo) восстанавливался только последний удаленный компонент, а не вся структура целиком.

## Причины проблемы

Проблема возникала из-за нескольких факторов:

1. **Структурная зависимость**: Стек и его узлы выбора - это логически связанные элементы, но в системе команд они обрабатывались независимо.

2. **Несогласованность в обработке группового удаления**: Метод `deleteSelectedNodes()` в `CommandManager` обрабатывал каждый выбранный узел отдельно, не учитывая родительско-дочерние отношения.

3. **Двойная обработка в onNodesChange**: Метод `onNodesChange()` в `useGraphStore` также создавал отдельные команды удаления для каждого узла.

4. **Неполное сохранение состояния**: Класс `DeleteStackNodeCommand` сохранял только информацию о самом стеке, но не о его дочерних узлах выбора.

## Решение

Решение проблемы включает несколько изменений:

### 1. Улучшение класса DeleteStackNodeCommand

Мы переработали класс `DeleteStackNodeCommand`, чтобы он:

```typescript
export class DeleteStackNodeCommand implements Command {
  private stackId: string;
  private stackNode: StackNode | null = null;
  private childNodes: ChoiceNode[] = [];
  private connectedLinks: Link[] = [];
  // ... остальной код
}
```

- Теперь сохраняет полное состояние стека и всех его дочерних узлов выбора
- Сохраняет все связи, относящиеся к стеку и его узлам выбора
- Восстанавливает всю структуру целиком при отмене операции
- Явно обновляет состояние канваса для корректного визуального отображения

### 2. Улучшение метода deleteSelectedNodes в CommandManager

Изменили метод `deleteSelectedNodes()` в классе `CommandManager`, чтобы он:

```typescript
public deleteSelectedNodes(): void {
  // ... код инициализации
  
  // Определяем, какие узлы уже были обработаны
  const processedNodeIds = new Set<string>();
  
  for (const nodeId of existingSelectedNodeIds) {
    // Пропускаем узлы, которые уже были обработаны ранее
    if (processedNodeIds.has(nodeId)) continue;
    
    // ... обработка разных типов узлов
    
    switch (node.type) {
      case 'stack':
        // Помечаем дочерние узлы как обработанные
        Object.values(currentLayer.nodes).forEach((n) => {
          if (n.type === 'choice' && 'parentId' in n && n.parentId === nodeId) {
            processedNodeIds.add(n.id);
          }
        });
        // Удаляем весь стек одной командой
        this.deleteStackNode(nodeId);
        break;
      
      case 'choice': {
        // Проверяем, не выбран ли родительский стек
        const parentId = (node as ChoiceNode).parentId;
        
        // Если родительский стек не выбран или уже обработан
        if (!existingSelectedNodeIds.includes(parentId) || processedNodeIds.has(parentId)) {
          this.deleteChoiceNode(nodeId);
        }
        break;
      }
      // ... обработка других типов узлов
    }
    
    processedNodeIds.add(nodeId);
  }
}
```

- Отслеживает, какие узлы уже были обработаны
- При удалении стека помечает все его дочерние узлы выбора как обработанные
- Для узлов выбора проверяет, не выбран ли также их родительский стек

### 3. Изменение метода onNodesChange в useGraphStore

Улучшили метод `onNodesChange()` в сторе `useGraphStore`:

```typescript
onNodesChange: (changes: NodeChange[]) => {
  // ... код инициализации
  
  // Определяем, какие узлы уже были обработаны
  const processedNodeIds = new Set<string>();
  
  // Сначала обрабатываем стеки
  for (const change of changes) {
    if (change.type === 'remove' && 'id' in change) {
      const nodeId = change.id;
      if (updatedNodes[nodeId] && updatedNodes[nodeId].type === 'stack') {
        // Обработка стека и пометка дочерних элементов
        // ...
      }
    }
  }
  
  // Затем обрабатываем все остальное
  for (const change of changes) {
    // Пропускаем узлы, которые уже были обработаны
    if (processedNodeIds.has(nodeId)) continue;
    
    // ... обработка разных типов изменений
  }
}
```

- Обрабатывает стеки в первую очередь
- Отслеживает и пропускает уже обработанные узлы
- Для узлов выбора проверяет наличие родительского стека в списке изменений

## Архитектурные улучшения

Эти изменения не только исправили конкретную проблему, но и улучшили архитектуру системы:

1. **Атомарность операций**: Теперь удаление сложных структур (стек + узлы выбора) является атомарной операцией для истории команд.

2. **Сохранение целостности данных**: Сложные структуры всегда сохраняются и восстанавливаются целиком.

3. **Улучшение паттерна Command**: Команды теперь лучше понимают структуру и взаимосвязи между объектами.

4. **Предотвращение дублирования**: Система избегает создания множества отдельных команд для логически связанных объектов.

## Технические детали

- **Глубокое копирование**: Важно создавать глубокие копии объектов (`{...node}`) для сохранения в командах, чтобы избежать проблем с изменяемыми объектами.

- **Управление зависимостями**: При удалении нужно отслеживать не только сами узлы, но и их связи (`connectedLinks`).

- **Синхронизация канваса**: После операций с историей важно синхронизировать состояние канваса (`canvasStore.setNodes()`, `canvasStore.setEdges()`).

- **Сохранение в localStorage**: Не забывать вызывать `saveToLocalStorage()` после изменений для сохранения состояния.

## Результат

После внесенных изменений:

- Удаление стека с узлами выбора создает только **одну запись** в истории команд
- Операции undo/redo корректно восстанавливают всю структуру целиком
- Система стала более согласованной и надежной

Эти изменения сделали работу с редактором более удобной и предсказуемой, особенно при работе со сложными структурами. 