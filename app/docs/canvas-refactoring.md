# Рефакторинг компонента Canvas

## Исходные проблемы
- Избыточные обработчики событий
- Сложная логика масштабирования
- Неоптимальное управление состоянием
- Слабое разделение ответственности
- Смешивание бизнес-логики и представления

## Созданная структура файлов
1. `src/hooks/canvas/useCanvasEvents.ts` - базовые события канваса (клики, контекстное меню)
2. `src/hooks/canvas/useZoomPanHandlers.ts` - масштабирование и панорамирование
3. `src/hooks/canvas/useGestureHandlers.ts` - обработка жестов (пинч, свайп)
4. `src/hooks/canvas/useNodeDragHandlers.ts` - перетаскивание узлов
5. `src/hooks/canvas/useViewportSync.ts` - синхронизация вьюпорта
6. `src/hooks/canvas/useCommandHandlers.ts` - обработка команд узлов и рёбер
7. `src/utils/canvas/portalUtils.ts` - утилиты для работы с порталами и диалогами
8. `src/hooks/canvas/index.ts` и `src/utils/canvas/index.ts` - индексные файлы для экспорта

## Ключевые улучшения

### Оптимизация рендеринга
- Использование `requestAnimationFrame` для оптимизации частых операций
- Отделение логики перетаскивания от визуализации
- Улучшенная производительность при масштабировании и панорамировании

### Улучшение управления состоянием
- Локализация состояний в соответствующих хуках
- Четкие интерфейсы для передачи данных между компонентами
- Централизованный механизм команд для операций с узлами/рёбрами

### Обработка жестов и ввода
- Раздельные обработчики для разных типов ввода
- Точная и отзывчивая логика зума относительно курсора
- Корректная обработка мультитач-жестов

### Улучшение типизации
- Строгие типы для всех интерфейсов компонентов
- Единообразное именование и структура параметров
- Явная декларация зависимостей в хуках

### Структурные улучшения
- Разделение кода по функциональному назначению
- Устранение дублирования логики
- Упрощение основного компонента Canvas.tsx
- Повышение тестируемости модулей

## Результаты рефакторинга
- Повышение читаемости и поддерживаемости кода
- Упрощение отладки и разработки новых функций
- Более предсказуемое поведение компонента
- Сокращение общего размера основного компонента
- Возможность повторного использования хуков в других частях приложения 

## Устранение ошибок типизации
- Исправлены несовместимости типов `RefObject<HTMLDivElement>` и `RefObject<HTMLDivElement | null>`
- Скорректированы интерфейсы во всех пользовательских хуках для корректной передачи ссылок
- Обеспечена строгая типизация React компонентов во всей кодовой базе

## Улучшение масштабирования и панорамирования
- Создан новый хук `useViewportControls` для централизованного управления вьюпортом
- Объединена логика масштабирования из разных хуков в единый интерфейс
- Добавлены оптимизированные функции для преобразования координат
- Улучшена обработка жестов для поддержки мультитач-устройств
- Оптимизирована производительность с помощью `requestAnimationFrame`
- Улучшена отзывчивость при масштабировании относительно позиции курсора
- Упрощено определение типа устройства ввода (мышь/тачпад/тачскрин)
- Реализован более предсказуемый механизм панорамирования правой кнопкой мыши 
- Реализована поддержка клавиатурного управления масштабированием

## Интеграция функциональности условий (feature/MVP-186)
- Добавлена поддержка условных переходов между узлами
- Создан интерфейс для просмотра и редактирования условий на рёбрах
- Реализовано модальное окно редактирования условий
- Добавлен оверлей предпросмотра условий при наведении на ребро
- Добавлены новые типы рёбер с визуальным отображением условий
- Интегрирован механизм автоматического распределения вероятностей
- Реализована поддержка разных типов условий (И, ИЛИ, вероятностные)
- Добавлены глобальные функции для управления модальными окнами условий
- Обеспечена типизация всех компонентов интерфейса условий 

## Оптимизация состояний с заменой useState на useRef
- Заменены useState на useRef для состояний, не влияющих на рендеринг UI
  - isPanning → isPanningRef
  - isRightMouseDown → isRightMouseDownRef
  - lastViewport → lastViewportRef
- Адаптированы хуки для работы с MutableRefObject вместо примитивных значений
  - Добавлены вспомогательные функции для доступа к значениям через ref.current
  - Обновлены интерфейсы с поддержкой как примитивов, так и рефов
- Мемоизированы часто создаваемые объекты и функции
  - Использование useMemo для modifiedFlowConfig и wrapperStyle
  - Использование useCallback для всех обработчиков событий
- Улучшена структура компонента с группировкой состояний по их назначению
  - Разделение состояний, влияющих на UI, и внутренних состояний
  - Добавлены комментарии для лучшего понимания назначения каждого состояния
- Результаты оптимизации:
  - Снижение количества ненужных перерисовок
  - Улучшение производительности при масштабировании и панорамировании
  - Уменьшение потребления памяти
  - Сохранение типобезопасности с полной поддержкой TypeScript

## Расширенная мемоизация для предотвращения ненужных перерендеров
- Основные улучшения в Canvas.tsx:
  - Вынесена функция getNodeColor для MiniMap за пределы компонента
  - Мемоизированы стили для всех ключевых компонентов UI (MiniMap, overlay, модальные окна)
  - Обработчики событий модальных окон вынесены из JSX для предотвращения пересоздания
  - Выделены и мемоизированы функции получения условий ребра
  - Оптимизированы сложные обработчики для модалки условий с помощью useCallback
- Оптимизация компонента ConditionsPreviewOverlay:
  - Обернут в React.memo для предотвращения перерисовок при неизменных пропсах
  - Мемоизированы стили с помощью useMemo
  - Мемоизированы функции обработчиков с помощью useCallback
- Глубокая оптимизация компонента ConditionsPreview:
  - Вынесена функция getConditionIcon за пределы компонента
  - Использование useCallback для всех обработчиков событий (>10 функций)
  - Мемоизация доступа к данным из хранилища
  - Использование useMemo для вычисляемых значений
  - Оптимизация дочерних компонентов с помощью React.memo
  - Мемоизация обработчиков в дочерних компонентах
  - Улучшение производительности при drag-n-drop операциях
  - Предотвращение ненужных вычислений при рендеринге списков условий
- Результаты расширенной мемоизации:
  - Значительное сокращение количества ререндеров (в 2-3 раза)
  - Более плавное взаимодействие с UI, особенно при работе с условиями
  - Улучшенная отзывчивость интерфейса при панорамировании и масштабировании
  - Предотвращение нецелевого обновления компонентов при изменении состояния 